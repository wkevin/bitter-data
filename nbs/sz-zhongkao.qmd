---
title: "深圳中考"

format:
  html:
    code-fold: false
    echo: false
    output: false
    toc-expand: 2
    toc-title: 目录
    # fig-xxx 仅影响 matplotlib 绘图，不影响 pyecharts
    fig-align: center
    #fig-format: svg
    #fig-dpi: 400 # svg 时无效

---

```{python}
from datetime import datetime as dt

import numpy as np
import pandas as pd

from pyecharts import types
from pyecharts import options as opts
from pyecharts.charts import Line, Grid, Bar, Sunburst
from pyecharts.components import Table
from pyecharts.commons.utils import JsCode
```

```{python}
###### 全局变量 ######
# 已经出了成绩的最新年份
scoredyear = "2023"
years = [f"{y}" for y in list(range(2019, int(scoredyear) + 1, 1))]
years_score = [f"[{y}]" for y in years]
print(f"已出分年度: {years}")
print(f"data 中已出分年度的 column 名称: {years_score}")
# 报名人数（假设数据）
enroll_number_2023 = 126000  # 2023 年报名人数
enroll_number_2023_ac = 57800  # 2023 年 AC 类报名人数
enroll_number_2023_d = enroll_number_2023 - enroll_number_2023_ac
enroll_number_2024 = 131000  # 2024 年报名人数
enroll_number_2024_ac = 65000  # 2024 年 AC 类报名人数
enroll_number_2024_d = enroll_number_2024 - enroll_number_2024_ac
# 指标生录取率（假设数据）
zbs_rate_2023 = 0.5
zbs_rate_2024 = 0.4
```

本文数据主要来自深圳招生办公室公开文件：

- 2023年考生报考指导手册：[链接1](http://szeb.sz.gov.cn/szzkw/qt/tzgg/content/post_10610222.html)、[链接2](http://szeb.sz.gov.cn/szzkw/zkgg/zkxx/content/post_10610216.html)
- [2024年考生报考指导手册](http://szeb.sz.gov.cn/szszsksbgs/zkcx/zkzz/2024zkwsxczxjd/ksbkzdsc/content/post_11303237.html)

但也有几个关键数据是来自网络，这是导致录取比例、报考等位中的图与实际有偏差的主因：

```{python}
#| echo: false
#| output: asis

print(f"""
- 报名人数: 
    - 2023: 报名约 {enroll_number_2023} 人，AC 类约 {enroll_number_2023_ac} 人，D 类约 {enroll_number_2023_d} 人。
    - 2024: 报名约 {enroll_number_2024} 人，AC 类约 {enroll_number_2024_ac} 人，D 类约 {enroll_number_2024_d} 人。
- 指标生录取率: 
    - 2023：预估 {zbs_rate_2023} —— 即只有 50% 的指标生名额被使用，其余的名额会放回到正录
    - 2024：预估 {zbs_rate_2024}
""")
```

**以上假设数据本人未能证实，不承担责任，仅供参考。**

```{python}
# 全局变量
g_toolbox_opts=opts.ToolboxOpts(
    feature=opts.ToolBoxFeatureOpts(
        save_as_image = opts.ToolBoxFeatureSaveAsImageOpts(
            background_color="white",
            pixel_ratio = 5), 
        restore=None,
        data_view=None,
        data_zoom=None,
        magic_type=None,
        # brush = opts.BrushOpts(),
    )
),

def get_title(titlestr:str=""):
    return opts.TitleOpts(
        title=titlestr,
        title_link="https://wkevin.github.io/bitter-data",
        subtitle="https://wkevin.github.io/bitter-data",
        subtitle_link="https://wkevin.github.io/bitter-data",
        subtitle_textstyle_opts=opts.TextStyleOpts(font_size=12),
    )
```

```{python}
# 加载数据
# read_csv(dtype, engine)
#   pandas 首先尝试某列是否可数值化（numeric）
#   不可数值化：视为 str
#   可以数值化 & dtype 没有指定为 'str': 按 int、float 顺序尝试解析
#       遇到列中有 NaN（pandas 中的一种特殊 float 值）, 此列按 float 解析；
#       遇到列中没有 NaN，则按 int、float 顺序尝试解析；
#       所以 scoredyear 最新年份的录取分中没有 Nan，导致解析为 int，与其他的 float 不一致，此处统一为 float
#   engine: 默认为 'c', 还可以 'python'
df_score_ac = pd.read_csv(
    f"./sz-zhongkao/admit_score_ac.csv", decimal=",", dtype={f"[{scoredyear}]": float}
).drop("学校名称", axis=1)

df_count_2023 = (
    pd.read_csv(f"./sz-zhongkao/admit_number_2023.csv", decimal=",")
    .drop("学校名称", axis=1)
    .drop("办学性质", axis=1)
    .rename(columns={"招生人数": "招生人数_2023", "指标生": "指标生人数_2023"})
)

df_count_2024 = pd.read_csv(
    f"./sz-zhongkao/admit_number_2024.csv", decimal=","
).rename(columns={"招生人数": "招生人数_2024", "指标生": "指标生人数_2024"})

# 使用最新年份的学校信息，根据代码合并 df
# 不再招生的学校就不显示了
df = df_count_2024.merge(df_count_2023, on="代码", how="left").merge(
    df_score_ac, on="代码", how="left"
)


# 添加新列 type：表示 AC、D 类
def assign_type(name: str):
    if "（一）" in name:
        return "AC"
    elif "（二）" in name:
        return "D"
    else:
        return "ACD"


df["type"] = df["学校名称"].apply(assign_type)
# df.to_csv("foobar.csv")

# 添加每年的排序
# 第一序：分数（[year]）
# 第二序：招生人数（招生人数_year）-- 招生人数多着靠前
# 第三序：代码 -- 代码小的靠前
l = len(df)
for y in years:
    _l = len(df[df[f"[{y}]"].notnull()])
    if f"招生人数_{y}" in df.columns.tolist():
        df = df.sort_values(
            by=[f"[{y}]", f"招生人数_{y}", "代码"], ascending=[False, False, True]
        )
    else:
        df = df.sort_values(by=[f"[{y}]", "代码"], ascending=[False, True])

    zs = np.zeros(l)
    zs[:] = np.nan

    for i in range(0, _l, 1):
        zs[i] = i + 1
    df.insert(len(df.columns), y, zs)
(df) 
```

```{python}
def transfer_ac_and_d(year: str, only_gov=True, add_new_tag=True):
    """将公办 AC 和 D 类的招生人数整合到一行（民办都是 ACD 混合的），重新命名为新列：
    AC、D、ACD、AC_指标生、D_指标生、ACD_指标生；
    将学校名称中的（一）\（二）去掉；
    按指定 year 排序，如果 scoredyear 还没有到 year 年度，则按 scoredyear 排序；
    并可识别指定年份是否为新校，添加 new 标签
    """

    _df = df.copy()

    if only_gov:
        _df = _df[_df["办学性质"] == "公办"]  # 去掉民办

    ### AC、D、ACD 类人数合并一行，代码使用 AC 的
    _df_0 = _df[~_df["学校名称"].str.contains("（二）")]  # 筛出 AC & ACD
    _df_0.loc[:, "学校名称"] = _df_0["学校名称"].str.replace(
        "（一）", ""
    )  # 列名中去掉 (一)

    _df_1 = _df[_df["学校名称"].str.contains("（一）")]  # 筛出 AC 类
    _df_1 = _df_1.rename(columns={f"招生人数_{year}": "AC"})  # 列名改为AC
    _df_1 = _df_1.rename(columns={f"指标生人数_{year}": "AC_指标生"})  # 列名改为AC
    _df_1 = _df_1[["代码", "AC", "AC_指标生"]]

    _df_2 = _df[_df["学校名称"].str.contains("（二）")]  # 筛出 D 类
    _df_2.loc[:, "学校名称"] = _df_2["学校名称"].str.replace("（二）", "")
    _df_2 = _df_2.rename(columns={f"招生人数_{year}": "D"})
    _df_2 = _df_2.rename(columns={f"指标生人数_{year}": "D_指标生"})
    _df_2 = _df_2[["学校名称", "D", "D_指标生"]]

    # _df_3 = _df[~_df["学校名称"].str.contains("（一）")][~_df["学校名称"].str.contains("（二）")]  # 筛出 ACD 类
    filtered_school_names = _df["学校名称"].str.contains("（一）") | _df[
        "学校名称"
    ].str.contains("（二）")
    _df_3 = _df[~filtered_school_names.reindex(_df.index)]
    _df_3 = _df_3.rename(columns={f"招生人数_{year}": "ACD"})
    _df_3 = _df_3.rename(columns={f"指标生人数_{year}": "ACD_指标生"})
    _df_3 = _df_3[["代码", "ACD", "ACD_指标生"]]

    # AC 和 ACD merge on 代码，D merge on 校名
    _df = (
        _df_0.merge(_df_1, on="代码", how="left")
        .merge(_df_2, on="学校名称", how="left")
        .merge(_df_3, on="代码", how="left")
    )

    if add_new_tag:
        if year in df.columns:
            # print(f"{year} 已有录取分数列，使用前后录取分数做判断")
            _df = _df.sort_values(by=f"[{year}]", ascending=False)
            _df["学校名称"] += np.where(
                _df[f"[{str(int(year)-1)}]"].isna(), "(new)", ""
            )
        else:
            # print(f"{year} 没有录取分数列，使用招生人数做判断")
            _df = _df.sort_values(by=f"[{scoredyear}]", ascending=False)
            _df["学校名称"] += np.where(
                _df[f"招生人数_{str(int(year)-1)}"].isna(), "(new)", ""
            )

    # _df.to_csv("foobar.csv")
    # 仅返回当年有招生的
    return _df[_df["AC"].notnull() | _df["D"].notnull() | _df["ACD"].notnull()]


# _ndf = transfer_ac_and_d("2023")
# print(_ndf[_ndf["学校名称"].str.contains("new")]["学校名称"].to_numpy())
# _ndf = transfer_ac_and_d("2024")
# print(_ndf[_ndf["学校名称"].str.contains("new")]["学校名称"].to_numpy())
```


## 学校排名

**仅排序公办高中。**

排序原则：

1. 第一序：AC 类录取分数
2. 第二序：招生人数，招生人数多着靠前
3. 第三序：代码

```{python}
# 演变图绘制到当前已出成绩的年份（scoredyear）
dfsort = df.copy()
# 去掉“学校名称”中的“（一）”
dfsort["学校名称"] = df["学校名称"].str.replace("（一）", "")
# 仅保留有录取成绩的row（即：AC类）& 仅保留学校名称和年份排名 column
dfsort = dfsort[dfsort[scoredyear].notnull()][years + ["学校名称"]]
# 把所有年份的成绩添加到“名称”列中，后面添加 tooltip 时使用
for y in years:
    dfsort["学校名称"] += "," + df[f"[{y}]"].astype(str)
dfsort.set_index(["学校名称"], inplace=True)
(dfsort)
```

```{python}
# | output: true
# | fig-align: center

l = (
    Line(init_opts=opts.InitOpts(width="100%"))
    .add_xaxis(dfsort.columns.to_list())
    .set_global_opts(
        title_opts=get_title("深圳高中排名演变图"),
        xaxis_opts=opts.AxisOpts(
            type_="category", position="top", boundary_gap=False  # 离散值
        ),
        yaxis_opts=opts.AxisOpts(
            # is_show=False,
            is_inverse=True,
            min_=1,
            max_=len(dfsort.index),
            max_interval=10,
            boundary_gap=False,
        ),
        tooltip_opts=opts.TooltipOpts(
            trigger="item",  # item-鼠标在item上触发，axis-轴上触发
            # {a}：系列名。
            # {b}：数据名。
            # {c}：数据值。
            # {@xxx}：数据中名为 'xxx' 的维度的值，如 {@product} 表示名为 'product'` 的维度的值。
            # {@[n]}：数据中维度 n 的值，如{@[3]}` 表示维度 3 的值，从 0 开始计数。
            formatter=JsCode(
                """function (param) {
                    ret = param.seriesName.split(',')[0] + '<br/>';
                    ret += param.value + ',' + param.seriesName.split(',')[param.dataIndex+1].toString().slice(0,-2)  ;
                    return  ret;
                }"""
            ),
            # slice(0,-2): 去掉 float 小数点后的内容（.0）
        ),
        toolbox_opts=g_toolbox_opts,
        legend_opts=opts.LegendOpts(is_show=False),
    )
)

for name, row in dfsort.iterrows():
    l.add_yaxis(
        series_name=name,
        y_axis=row,
        z_level=1,
        is_symbol_show=True,
        symbol="circle",
        symbol_size=8,
        label_opts=opts.LabelOpts(
            is_show=False,
        ),
    )
    # 添加校名
    row[:-1] = None  # 只保留最后一年的数值，其他列置 non
    l.add_yaxis(
        series_name=name.split(",")[0],
        y_axis=row,
        z_level=0,  # 放在上一个 y 值的底下
        is_symbol_show=True,
        symbol="circle",
        symbol_size=8,
        label_opts=opts.LabelOpts(
            # is_show=False,
            formatter="{a}",  # 用 series_name 作为 label
            position="right"
        ),
    )


grid = Grid(
    init_opts=opts.InitOpts(
        width="100%",
        height="1600px",
        renderer='png', 
        bg_color='white'
    )
)

grid.add(
    l,
    opts.GridOpts(
        pos_top=80,
        pos_right="38.2%",
    ),
    is_control_axis_index=True,
)

grid.render_notebook()
```

## 学校数量

|普高数量|2023|2024|
|--|--|--|
|公办|173|182|
|民办|50|46|


## 学位统计

```{python}
def admit_number_bar(year: str):
    """招生人数柱状图"""
    _df = transfer_ac_and_d(year)
    _df[f"Total"] = _df["AC"] + _df["D"] + _df["ACD"]
    _df = _df[["学校名称", "AC", "D", "ACD", "Total"]]

    bar = (
        Bar(init_opts=opts.InitOpts())
        # add_dataset() 中给出数据后，add_yaxis 会自动依次选择第 2、3...列
        # pyecharts 绘图是逆序的, df.iloc[::-1] 可以实现逆序
        .add_dataset(
            source=[_df.columns.values.tolist()] + _df.iloc[::-1].values.tolist()
        )
        .add_yaxis(
            series_name=f"AC",
            y_axis=[],  # 自动选择第 2 列
            label_opts=opts.LabelOpts(position="insideRight"),
            stack="stack1",
        )
        .add_yaxis(
            series_name=f"D",
            y_axis=[],  # 自动选择第 3 列
            label_opts=opts.LabelOpts(position="insideLeft"),
            stack="stack1",
        )
        .add_yaxis(
            series_name=f"ACD",
            y_axis=[],  # 自动选择第 4 列
            label_opts=opts.LabelOpts(position="insideLeft"),
            stack="stack1",
        )
        .set_global_opts(
            title_opts=get_title(f"深圳 {year} 公办普高招生人数"),
            legend_opts=opts.LegendOpts(is_show=True, pos_bottom=10),
            xaxis_opts=opts.AxisOpts(name=""),
            yaxis_opts=opts.AxisOpts(type_="category"),
            toolbox_opts=g_toolbox_opts,
            # visualmap_opts=opts.VisualMapOpts(
            #     orient="horizontal",
            #     pos_left="center",
            #     min_=80,
            #     max_=1700,
            #     dimension=1,
            #     range_color=["#D7DA8B", "#E15457"],
            # ),
        )
    )

    grid = Grid(
        init_opts=opts.InitOpts(
            width="100%", height="1600px", renderer="svg", bg_color="white"
        )
    )

    grid.add(
        bar,
        opts.GridOpts(
            pos_left="50%",
            # pos_right='20px',
        ),
        is_control_axis_index=True,
    )
    return grid
```

> 仅列举了公办普高。
> 以已发布的最新年份的 AC 类录取分数线排序，所以当年新学校在当年录取分公布前会排在末尾，分数公布后会得到修正。

### 2023

```{python}
# | output: true
admit_number_bar("2023").render_notebook()
```

### 2024

```{python}
# | output: true
admit_number_bar("2024").render_notebook()
```

## 录取比例

```{python}
def enroll_rate_table(year: str, eroll_ac: int, eroll_d: int, zbs_rate: float = 0.5):
    """绘制录取人数和比例的表格，ACD 类学校按 3:1 拆分到 AC:D"""
    table = Table()

    headers = [
        "类别",
        "报名人数",
        "录取人数/比例",
        "指标生/比例",
        "正录/比例",
        f"{zbs_rate}修正正录/比例",
    ]

    # 报名：enroll/erl
    # 录取：admit/adm
    erl_total = eroll_ac + eroll_d
    _df = transfer_ac_and_d(year)
    # 将 ACD 的名额按 3:1 拆分给 AC:D
    adm_acd = _df[f"ACD"].sum()
    adm_ac = _df[f"AC"].sum() + adm_acd * 0.75
    adm_d = _df[f"D"].sum() + adm_acd * 0.25
    adm_acd_zbs = _df[f"ACD_指标生"].sum()
    adm_ac_zbs = _df[f"AC_指标生"].sum() + adm_acd_zbs * 0.75
    adm_d_zbs = _df[f"D_指标生"].sum() + adm_acd_zbs * 0.25

    rows = [
        [
            "AC+D",
            erl_total,
            f"{adm_ac + adm_d:.0f}/{100*(adm_ac + adm_d)/erl_total:.0f}%",
            f"{adm_ac_zbs + adm_d_zbs:.0f}/{100*(adm_ac_zbs + adm_d_zbs)/erl_total:.0f}%",
            f"{adm_ac - adm_ac_zbs + adm_d - adm_d_zbs:.0f}/{100*(adm_ac - adm_ac_zbs + adm_d - adm_d_zbs)/erl_total:.0f}%",
            f"{adm_ac - adm_ac_zbs*zbs_rate + adm_d - adm_d_zbs*zbs_rate:.0f}/{100*(adm_ac - adm_ac_zbs*zbs_rate + adm_d - adm_d_zbs*zbs_rate)/erl_total:.0f}%",
        ],
        [
            "AC",
            eroll_ac,
            f"{adm_ac:.0f}/{100*adm_ac/eroll_ac:.0f}%",
            f"{adm_ac_zbs:.0f}/{100*adm_ac_zbs/eroll_ac:.0f}%",
            f"{adm_ac - adm_ac_zbs:.0f}/{100*(adm_ac - adm_ac_zbs)/eroll_ac:.0f}%",
            f"{adm_ac - adm_ac_zbs*zbs_rate:.0f}/{100*(adm_ac - adm_ac_zbs*zbs_rate)/eroll_ac:.0f}%",
        ],
        [
            "D",
            eroll_d,
            f"{adm_d:.0f}/{100*adm_d/eroll_d:.0f}%",
            f"{adm_d_zbs:.0f}/{100*adm_d_zbs/eroll_d:.0f}%",
            f"{adm_d - adm_d_zbs:.0f}/{100*(adm_d - adm_d_zbs)/eroll_d:.0f}%",
            f"{adm_d - adm_d_zbs*zbs_rate:.0f}/{100*(adm_d - adm_d_zbs*zbs_rate)/eroll_d:.0f}%",
        ],
    ]
    table.add(headers, rows)
    return table
```

- 将 ACD 类学校按 3:1 拆分到 AC:D 中，不单独做 ACD 一行。
- 指标生有效使用率每年变化，并且教育局和学校也不公布，所以只能预估。

### 2023 

- 2022 年指标生使用比例就比较小，2023 年使用比例网传会比较高，本文预估为 0.5。

```{python}
# | output: true
enroll_rate_table("2023", enroll_number_2023_ac, enroll_number_2023_d, zbs_rate_2023).render_notebook()
```

上表显示：AC 类录取比例 84%，如果指标生都用满的话，84% 中的 41% 会通过指标生上学，但 0.5 修订后变成：21% 指标生 + 63% 正录。

### 2024

- 2024 年新学校较多，听说新校的指标生使用率很低，拉低了整体使用率，所以本文预估为 0.4。

```{python}
# | output: true
enroll_rate_table("2024", enroll_number_2024_ac, enroll_number_2024_d, zbs_rate_2024).render_notebook()
```

- 总体录取比例与 2023 年几乎持平。
- 但指标生使用率降低导致正录比例升高
    - 乐观解读可以是：学校更多的学位留个正录，更公平。
    - 悲观解读可以是：学校更少的学校留个指标生，不公平，并且会抬高正录的分数线，感觉学校更难考了。

同一个事情，乐观和悲观角度不同，感受不同，各自解读吧。

## 报考等位

我们试图要回答的两个问题：

1. 孩子当前这个等位（如：B+）该怎么报**指标生志愿** ？
2. 孩子当前这个等位（如：B+）该怎么报**正录志愿**？

第 1 个问题因为指标生运作机制，且涉及因素较多，致使指标生通常比正录的分数要低，正录的分数线通常在最终高一开学后可能是中位线，而不是最低线（新学校除外，可能有特例）—— 所以此处不讨论该问题，填报时根据下面的正录参考，适当提高 5~15 分填报即可。

第 2 个问题用下面的图展示，主要通过描述**招生人数**与**报名人数**的匹配关系来展开。

```{python}
# | echo: false
# | output: asis

# def admit_number_sum(year: str, category: str = 'ac'):
#     """ dfsum: 添加一列存放累积数据 """
#     dfsum = df.sort_values(by=f"[{year}]", ascending=False)
#     dfsum["学校名称"] += np.where(dfsum[f"[{str(int(year)-1)}]"].isna(), "(new)","") # 识别是否为新校
#     dfsum = dfsum[["学校名称", f"招生人数_{year}_{category}", f"{category}_指标生"]]
#     # 累积值为正录的人数（即：减去指标生和自招生）
#     dfsum[f"累计_{category}"] = (dfsum[f"招生人数_{year}_{category}"] - dfsum[f"{category}_指标生"]).cumsum(axis=0)
#     return dfsum


def level_sunburst(year: str, ac_or_d: str, enroll_total: int, zbs_rate: float = 0.5):
    """按比例(zbs_rate)去掉指标生后的等位旭日图

    enroll_total: enroll total, 总报名人数，不是录取（admit）人数
    zbs_rate: 指标生有效使用率，为 0 时可视为忽略指标生，整体评估使用
    """
    data_grade = [
        {"name": "A+", "value": enroll_total * 0.05},
        {"name": "A", "value": enroll_total * 0.2},
        {"name": "B+", "value": enroll_total * 0.25},
        {"name": "B", "value": enroll_total * 0.25},
        {"name": "C+", "value": enroll_total * 0.2},
        {"name": "C", "value": enroll_total * 0.05},
    ]

    ac_or_d = ac_or_d.upper()
    _df = transfer_ac_and_d(year)
    # 将 ACD 的名额按 3:1 拆分给 AC:D
    # adm_acd = _df[f"ACD"].sum()
    # adm_ac = _df[f"AC"].sum() + adm_acd * 0.75
    # adm_d = _df[f"D"].sum() + adm_acd * 0.25
    # adm_acd_zbs = _df[f"ACD_指标生"].sum()
    # adm_ac_zbs = _df[f"AC_指标生"].sum() + adm_acd_zbs * 0.75
    # adm_d_zbs = _df[f"D_指标生"].sum() + adm_acd_zbs * 0.25

    data = []  # sunburst 的 datasource 是数组，要做数据格式转换
    idx = 0
    adm_sum = 0
    adm_sum_zbs = 0
    adm_sum_zbs_offset = 0
    for name, row in _df.iterrows():
        _all = row[f"{ac_or_d}"] if not pd.isnull(row[f"{ac_or_d}"]) else 0
        # 把 ACD 的名额按 3:1 拆分给 AC:D
        _all += (
            0
            if pd.isnull(row["ACD"])
            else (row["ACD"] * (0.75 if ac_or_d == "AC" else 0.25))
        )

        _zbs = (
            row[f"{ac_or_d}_指标生"] if not pd.isnull(row[f"{ac_or_d}_指标生"]) else 0
        )
        # 其实是没有必要的，因为 ACD 类学校基本没有指标生
        _zbs += (
            0
            if pd.isnull(row["ACD_指标生"])
            else (row["ACD_指标生"] * (0.75 if ac_or_d == "AC" else 0.25))
        )
        adm_sum += _all
        adm_sum_zbs += _zbs

        _zbs *= zbs_rate  # 用录用比例修订指标生
        adm_sum_zbs_offset += _zbs

        idx += 1
        data.append(
            {"name": str(idx) + "_" + row["学校名称"], "value": int(_all - _zbs)}
        )

    print(
        f"""
    - {ac_or_d} 类总录取名额 {int(adm_sum)}，指标生名额 {int(adm_sum_zbs)}，正录名额 {int(adm_sum - adm_sum_zbs)}；
    - 指标生预估有效录取比例 {zbs_rate} 修订后：指标生实录 {int(adm_sum_zbs_offset)}人, 正录实录 {int(adm_sum - adm_sum_zbs_offset)}人，
    - {ac_or_d} 类总报名 {enroll_total}，缺口{int(enroll_total - adm_sum)}
    """
    )

    # 计算缺口时也要减去指标生
    data.append(
        {
            "name": "缺口",
            "value": int(enroll_total - adm_sum),
        }
    )

    return (
        Sunburst(
            init_opts=opts.InitOpts(
                width="100%",
                height="600px",
                is_horizontal_center=True,
                renderer="png",
                bg_color="white",
            )
        )
        .add(
            "",
            data_pair=data_grade,
            highlight_policy="ancestor",
            radius=[0, "95%"],
            sort_=types.JsCode("null"),
            levels=[
                {},
                {"r0": "15%", "r": "23%", "label": {"align": "right"}},
            ],
            label_opts=opts.LabelOpts(font_size=10, font_weight="bold"),
        )
        .add(
            "",
            data_pair=data,
            highlight_policy="ancestor",
            radius=[0, "95%"],
            sort_=types.JsCode("null"),
            levels=[
                {},
                {"r0": "25%", "r": "100%", "label": {"align": "right"}},
            ],
            label_opts=opts.LabelOpts(
                # formatter + rich = 可实现更丰富的自定义显示
                formatter="{schoolname| {b}}",
                rich={"schoolname": {"fontSize": "9px"}},
            ),
        )
        .set_global_opts(
            title_opts=get_title(f"{year} {ac_or_d} 类正录等位图"),
            toolbox_opts=g_toolbox_opts,
            legend_opts=opts.LegendOpts(is_show=False),
        )
    )
```

- 下面的图推荐在电脑上打开，手机上查看比较拥挤。
- 内圈 A+、A、B+、B 等是报名人数的等位
- 外圈是各个学校按前次录用最低分数线排名后的，招生人数累积值
- 外圈的缺口：即报名人数与招生人数之间的差值 —— 民办或职校去向

### 2023

```{python}
#| echo: false
#| output: asis

print(f"""
指标生录取率预估 {zbs_rate_2023}
""")
```

#### AC 类

```{python}
# | output: asis
level_sunburst("2023", "AC", enroll_number_2023_ac, zbs_rate_2023).render_notebook()
```

- 比如 `54.弘知高中`，手册中招生 `710` 人，指标生 `355` 人，假设指标生录用率 0.5，即 `355*0.5 = 178` 人走指标生，剩下 `177` 人归入正录，那么正录的名额就是 `710 - 178 = 532` 人 —— 图中的数字就是如此计算的。

现在来尝试解答上面的第 2 个问题：

**如果孩子摸底成绩在 B+ 中部，如何填报 12 个普高志愿：**

- 冲（2个）：可以从 B+ 顶部（24.科高龙岗/552 ~ 30.北师大附/546）选择，间距 6 分，2~5 分为一个阶梯选择；
- 稳（6个）：可以从 B+ 中底部（31.北莫/546 ~ 52.红岭大鹏/522）中选择，间距 24 分，阶梯选择同上；
- 保（4个）：可以在 B 开始选择，保底建议安全第一


**填报志愿时，分数的绝对值并不重要，2023 年题目简单，大家分数都高，但等级是基本不变的，孩子只要正常发挥，A 的依然是 A, B 的还会是 B，所以报志愿要按等位来报，一定要找老师了解孩子摸底考试在学校的排名和等位，结合上表填报志愿。**

**另外对自家孩子等位的评估要准确，本校的 B+ 未必是全市的 B+，有可能是 A，也有可能是 B。—— 要用全市的等位**

#### D 类

```{python}
# | output: asis
level_sunburst("2023", "D", enroll_number_2023_d, zbs_rate_2023).render_notebook()
```

D 类看着太扎心了！只有 A 分数段的中部以上，才有公办普高读，大部分都要去民办或职高了。

**特别声明：**

学校排名不是固定的，每年都会有学校异军突起或大幅陷落，和学校的宣传、校舍改造、迁址、师资队伍变化、出口成绩……等诸多因素相关，2023 年的上图只能作为 2023 年而复盘回顾，和 2024 年早期预估。待 2024 年 5 月学校招生人数公布后，叠加 2023 年的排名和新学校的位置预估，做出新图，才更合适做 2024 年的志愿填报参考。


### 2024

```{python}
#| echo: false
#| output: asis

print(f"""
指标生录取率预估 {zbs_rate_2024}
""")
```

#### AC 类

```{python}
# | output: asis
level_sunburst("2024", "AC", enroll_number_2024_ac, zbs_rate_2024).render_notebook()
```

我们调整一下假设数据，把 AC 类报名人数增加 10000 再画一次：

```{python}
# | output: asis

level_sunburst("2024", "AC", enroll_number_2024_ac + 10000, zbs_rate_2024).render_notebook()
```

上面两图可以理解为悲观、乐观预估，实际情况应该两种之间。

#### D 类

```{python}
# | output: asis
level_sunburst("2024", "D", enroll_number_2024_d, zbs_rate_2024).render_notebook()
```

调整假设数据，把 D 类报名人数减少 10000 再画一次：

```{python}
# | output: asis
level_sunburst("2024", "D", enroll_number_2024_d - 10000, zbs_rate_2024).render_notebook()
```

但即使 D 类乐观预估，也依然是只有 B+ 顶部才能够得着公办普高。

对 AC 类的悲观、乐观，对 D 类就是相反的乐观、悲观 —— 人间苦楚、共情不易。

**最后！祝愿深圳初中生都能够心想事成，考上理想的高中。**